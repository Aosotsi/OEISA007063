# A Solution to the Kimberling Expulsion Conjecture

**Author:** Anta Osotsi

**Date:** October 21, 2025

This repository presents a proof for the Kimberling expulsion conjecture ([OEIS A007063](https://oeis.org/A007063)), which asks whether every positive integer eventually appears on its. The proof confirms that the answer is yes.

## Problem Statement: The Kimberling Shuffle

On February 1991, the mathematician Clark Kimberling proposed an intuitvely "simple"/straightforward problem in *CRUX MATHEMATICORUM Volume 17, #2*. It involved a pseudo-random process of generating an infinite array of numbers.

You start with the sequence of positive integers `S₁ = (1, 2, 3, ...)`.

To get the next row, you take the number on the diagonal (the *i*-th element in row *i*), remove it, and rearrange the remaining numbers by taking one from the right of the gap, one from the left, one from the right, and so on.

Here are the first few steps:

1.  **Row 1:** `[1] 2 3 4 5 6 ...` -> The number **1** is on the diagonal. We remove it.
2.  **Row 2:** `2 [3] 4 5 6 7 ...` -> The number **3** is on the diagonal. We remove it.
3.  **Row 3:** `4 2 [5] 6 7 8 ...` -> The number **5** is on the diagonal. We remove it.
4.  **Row 4:** `6 2 7 [4] 8 9 ...` -> The number **4** is on the diagonal. We remove it.
etc...

Using this algorithm, the main question practically writes itself: 

Does the sequence of these "expelled" diagonal numbers is `1, 3, 5, 4, 10, 7, ...` (OEIS A007063) remove every single n, n ∈ N? Essentially, **will every positive integer eventually be expelled?**

While the question has been computationally investigated by Enrique Pérez Herrero (from 1 to 20,000) and numerous others, a comprehensive proof has been elusive; until now.  

## Proof Strategy: Constructing A Funnel Lemma

This work proves that, **yes, every integer is eventually expelled**. The proof proceeds by contradiction.

1.  **Assume the Opposite**: Let's assume there's a set of integers that are *never* expelled. Let `n₀` be the smallest integer in this set.

2.  **Track the Distance**: Since `n₀` is never expelled, it's always present in the array. We can track its position at each step `i`. The core idea is to define a variable `δᵢ = i - (position of n₀)`, which measures the signed distance of `n₀` from the diagonal.
    *   If `δᵢ > 0`, `n₀` is to the left of the diagonal.
    *   If `δᵢ < 0`, `n₀` is to the right of the diagonal.
    *   If `δᵢ = 0`, `n₀` is on the diagonal and would be expelled (a contradiction).

3.  **The Funnel Lemma**: The proof's central argument is the **Funnel Lemma**. We show that for any step `i` and any possible distance `δᵢ`, the trajectory of `n₀` must, within **at most 4 steps**, either hit the diagonal (`δᵢ₊ₖ = 0`) or get strictly closer to it (`|δᵢ₊ₖ| < |δᵢ|`).

This behavior acts like a "funnel," forcing `n₀` inexorably toward the diagonal. An infinite descent is impossible within the naturals, so `n₀` must eventually land on the diagonal. This contradicts our initial assumption, proving that a never-expelled integer cannot exist.

## A Hybrid Approach: Computation Meets Theory

To prove the Funnel Lemma holds for all `i`, the proof is split into two parts:

1.  **Finite Computational Verification**: For "small" `i` (from 5 up to 200 in my paper's argument, and extended to 1000 in the included script), the behavor can be complex. We use a Python script to exhaustively check every possible starting condition `(i, δᵢ)`. This brute-force check confirms that the Funnel Lemma holds for over **1 million** initial states, with the maximum steps to descent being exactly 4.

2.  **Symbolic Asymptotic Proof**: For all `i` greater than our computational cutoff, we use a formal mathematical argument based on interval analysis. This symbolic proof shows that the "funneling" property is an inevitable feature of the system for large `i`, completing the proof for all integers.

By combining these two methods, we close the book on the problem, covering all possible cases.

## Repository Contents

*   `Final-Kimberling_Shuffle-27.pdf`: The full proof, including all derivations and lemmas.
*   `funnel_checkV4.py`: The Python 3 script used for the computational verification part of the proof.
*   `funnel_detailed_results.csv`: The CSV file generated by funnel_checkV4.py which enumerates all admissible pairs `(i, δᵢ)` in four columns - i, the distance of `n₀` from i, the steps required for perpetual descent, the sign pattern used.
*   `1615-Original-Crux_v17n02_Feb.pdf`: The original problem statement may be found on page 15/37 (labeled as page 44).
*   `README.md`: This file.
*   `Crux_v18n03_Mar.pdf`: Contains an extremely important derivation that we will use as `aᵢ`. Was first proposed by Iliya Bluskov, Technical University, Gabrovo, Bulgaria in 1992. 

## How to Verify the Computational Results

The computational claim can be independently verified by running the provided Python script.

**Requirements:**
*   Python 3.x

**Instructions:**
1.  Save the `funnel_checkV4.py` file to your computer.
2.  Run it from your terminal:
    ```bash
    python funnel_checkV4.py
    ```
3.  The script will start checking all allowed `(i, δ)` pairs for `i` between 5 and 1000. It will print its progress and a summary upon completion. The key result to look for is `Failures = 0`.
4.  Optionally, the script will also generate a CSV file `funnel_detailed_results.csv` (approx. 13.7 MB) containing the step count and trajectory pattern for every successful case. This can be disabled by setting `CSV_OUTPUT = False` in the script.

The script's successful execution provides extremely strong, reproducible evidence for the finite portion of the proof; which holds again, for over 1 million+ (!) pairs.

---
